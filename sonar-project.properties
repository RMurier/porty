# ===============================
# SonarQube configuration
# Project: Porty (ASP.NET Core + Vite/Node + SQL Server)
# Place this file at the repository root as: sonar-project.properties
# ===============================

# ---- Identification
sonar.projectKey=porty
sonar.projectName=Porty
sonar.projectVersion=1.0

# Optional: set your SonarQube server URL (override via CI env if needed)
# sonar.host.url=https://sonarqube.my-company.local

# Optional: authentication token (prefer passing via environment variable SONAR_TOKEN in CI)
# sonar.login=${env:SONAR_TOKEN}

# ---- Encoding
sonar.sourceEncoding=UTF-8

# ---- Monorepo layout
# We analyze API (C#) and Front (Vite/TS). List the root folders that contain source files.
sonar.sources=api,front

# ---- Global exclusions (node_modules, build outputs, generated/compiled assets, coverage artifacts)
sonar.exclusions=\
**/bin/**,\
**/obj/**,\
**/node_modules/**,\
**/dist/**,\
**/*.min.js,\
**/*.min.css,\
**/*.generated.*,\
**/*.g.cs,\
**/wwwroot/**

# ---- Test file patterns (for better separation of test code)
sonar.tests=api,front
sonar.test.inclusions=\
**/*Tests.cs,\
**/*.spec.ts,\
**/*.test.ts,\
**/*.spec.js,\
**/*.test.js

# ===============================
# C# / .NET settings
# ===============================
# Use the .NET SonarScanner in CI for full analysis (recommended):
#   dotnet tool install --global dotnet-sonarscanner
#   dotnet sonarscanner begin /k:"porty" /d:sonar.host.url="https://sonarqube.my-company.local" /d:sonar.login="$SONAR_TOKEN" \
#     /d:sonar.cs.opencover.reportsPaths="**/TestResults/**/coverage.opencover.xml" \
#     /d:sonar.cs.vstest.reportsPaths="**/TestResults/*.trx"
#   dotnet build ./api/Porty.sln
#   dotnet test ./api/Porty.sln --logger "trx;LogFileName=test-results.trx" /p:CollectCoverage=true /p:CoverletOutputFormat=opencover
#   dotnet sonarscanner end /d:sonar.login="$SONAR_TOKEN"
#
# If you run a generic scanner (sonar-scanner) instead, keep these properties:
sonar.cs.opencover.reportsPaths=**/TestResults/**/coverage.opencover.xml
sonar.cs.vstest.reportsPaths=**/TestResults/*.trx

# ===============================
# JavaScript / TypeScript (Vite front) settings
# ===============================
# LCov report generated by your front tests (Vitest/Jest). Example with Vitest:
#   npm ci
#   npm run test -- --coverage --coverage.reporter=lcov
# The LCOV file usually ends up at: front/coverage/lcov.info
sonar.javascript.lcov.reportPaths=front/coverage/lcov.info
sonar.typescript.lcov.reportPaths=front/coverage/lcov.info

# If you use ESLint reports (optional), you can import them:
# sonar.eslint.reportPaths=front/eslint-report.json

# ===============================
# Pull Request decoration (optional; set via CI environment)
# ===============================
# sonar.pullrequest.key=${env:PR_NUMBER}
# sonar.pullrequest.branch=${env:PR_BRANCH}
# sonar.pullrequest.base=${env:PR_BASE}
# sonar.pullrequest.provider=GitHub
# sonar.pullrequest.github.repository=RMurier/porty
# sonar.pullrequest.github.endpoint=https://api.github.com

# ===============================
# CI-friendly defaults
# ===============================
# Fail the analysis if the server is not reachable (CI surfacing)
sonar.scanner.forceGlobalAnalysis=true

# Narrow down file suffixes for clarity
sonar.cs.file.suffixes=.cs
sonar.javascript.file.suffixes=.js,.jsx,.mjs,.cjs
sonar.typescript.file.suffixes=.ts,.tsx

# Improve performance by excluding large binary blobs
sonar.inclusions=**/*.cs,**/*.ts,**/*.tsx,**/*.js,**/*.jsx,**/*.json,**/*.csproj,**/*.sln
