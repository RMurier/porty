name: CI/CD Porty

on:
  push:
    branches: [ develop, master ]
  pull_request:
    types: [opened, synchronize, reopened]

env:
  APP_NAME: porty
  REGISTRY: ghcr.io
  IMAGE_NAME: rmurier/porty
  PROD_HOST: "murierromain.com"
  STAGING_HOST: "test.murierromain.com"

jobs:
  # ------------------------------------------------------------
  # 1Ô∏è‚É£ TESTS & ANALYSE (ind√©pendant du d√©ploiement)
  # ------------------------------------------------------------
  analyze:
    name: üß™ Tests & Sonar Analysis
    runs-on: windows-latest

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "8.0.x"

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Restore dependencies
        run: dotnet restore ./api

      - name: Build backend
        run: dotnet build ./api -c Release

      - name: Test backend
        run: dotnet test ./api -c Release --no-build

      - name: Install frontend deps
        working-directory: front
        run: npm ci

      - name: Test frontend (si dispo)
        working-directory: front
        shell: bash
        run: |
          if npm run | grep -q "test"; then
            npm run test -- --coverage
          else
            echo "‚ö†Ô∏è Aucun test d√©fini, √©tape ignor√©e."
          fi

  # ------------------------------------------------------------
  # 2Ô∏è‚É£ BUILD & PUSH IMAGE (Docker Compose)
  # ------------------------------------------------------------
  docker:
    name: üê≥ Build & Push Image via docker-compose
    runs-on: ubuntu-latest
    if: github.ref_name == 'develop' || github.ref_name == 'master'
    outputs:
      image: ${{ steps.push.outputs.image }}

    steps:
      - uses: actions/checkout@v4

      - name: Login to GHCR
        run: echo "${{ secrets.TOKEN_GITHUB }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

      - name: Restore docker-compose from secrets
        id: compose
        run: |
          if [ "${GITHUB_REF_NAME}" = "master" ]; then
            echo "${{ secrets.DOCKER_COMPOSE_PROD_B64 }}" | base64 --decode > docker-compose.yml
            echo "compose_file=docker-compose.yml" >> $GITHUB_OUTPUT
          else
            echo "${{ secrets.DOCKER_COMPOSE_DEV_B64 }}" | base64 --decode > docker-compose.dev.yml
            echo "compose_file=docker-compose.dev.yml" >> $GITHUB_OUTPUT
          fi

      - id: build
        name: Build from docker-compose
        run: |
          FILE="${{ steps.compose.outputs.compose_file }}"
          echo "üöß Building environment from $FILE"
          docker compose -f "$FILE" up -d --build api
          docker ps

          IMAGE_TAG="ghcr.io/${{ env.IMAGE_NAME }}:${{ github.sha }}"
          echo "üè∑Ô∏è Tag ‚Üí $IMAGE_TAG"

          docker commit porty-api-dev "$IMAGE_TAG"
          docker push "$IMAGE_TAG"
          echo "image=$IMAGE_TAG" >> $GITHUB_OUTPUT

      - id: push
        run: echo "image=${{ steps.build.outputs.image }}" >> $GITHUB_OUTPUT

  # ------------------------------------------------------------
  # 3Ô∏è‚É£ DEPLOY TO K3S (en parall√®le des tests)
  # ------------------------------------------------------------
  deploy:
    name: üöÄ Deploy to K3S
    runs-on: ubuntu-latest
    needs: docker  # ‚öôÔ∏è uniquement besoin de l'image, pas des tests
    if: github.ref_name == 'develop' || github.ref_name == 'master'

    steps:
      - uses: actions/checkout@v4

      - name: Setup kubectl
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBE_CONFIG }}" > ~/.kube/config
          chmod 600 ~/.kube/config
          kubectl version --client

      - name: Create namespaces
        run: |
          kubectl apply -f k8s/namespace-prod.yaml || true
          kubectl apply -f k8s/namespace-staging.yaml || true

      - name: Select namespace
        id: envsel
        run: |
          if [ "${GITHUB_REF_NAME}" = "master" ]; then
            echo "namespace=production" >> $GITHUB_OUTPUT
          else
            echo "namespace=staging" >> $GITHUB_OUTPUT
          fi

      - name: Apply manifests
        run: |
          export APP_NAME=${{ env.APP_NAME }}
          export IMAGE=${{ needs.docker.outputs.image }}

          if [ "${GITHUB_REF_NAME}" = "master" ]; then
            export HOSTNAME=${{ env.PROD_HOST }}
          else
            export HOSTNAME=${{ env.STAGING_HOST }}
          fi

          echo "üåê Namespace: ${{ steps.envsel.outputs.namespace }}"
          echo "üì¶ Image: $IMAGE"
          echo "üè∑Ô∏è Host: $HOSTNAME"

          for file in k8s/*.yaml; do
            echo "üìÑ Applying $file with env substitution..."
            envsubst < "$file" | kubectl -n ${{ steps.envsel.outputs.namespace }} apply -f -
          done

      - name: Rollout update
        run: |
          kubectl -n ${{ steps.envsel.outputs.namespace }} set image deployment/${{ env.APP_NAME }} \
            ${{ env.APP_NAME }}=${{ needs.docker.outputs.image }} --record
          kubectl -n ${{ steps.envsel.outputs.namespace }} rollout status deployment/${{ env.APP_NAME }} --timeout=180s

      - name: Verify deployment
        run: |
          kubectl -n ${{ steps.envsel.outputs.namespace }} get pods -l app=${{ env.APP_NAME }}
          echo "‚úÖ Logs r√©cents :"
          kubectl -n ${{ steps.envsel.outputs.namespace }} logs -l app=${{ env.APP_NAME }} --tail=50
