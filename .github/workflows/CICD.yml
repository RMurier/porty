name: CI/CD Porty

on:
  push:
    branches: ['**']
  pull_request:
    types: [opened, synchronize, reopened]

env:
  APP_NAME: porty
  FRONT_APP_NAME: porty-front
  MAIN_SERVICE: api
  CONTAINER_PORT: "8080"
  HEALTH_PATH: "/"
  PROD_HOST: "murierromain.com"
  STAGING_HOST: "test.murierromain.com"
  REGISTRY: ghcr.io
  IMAGE_NAME: rmurier/porty
  FRONT_IMAGE_NAME: rmurier/porty-front

jobs:
  analyze:
    name: üß™ Analyse & Tests
    runs-on: windows-latest
    env:
      SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - uses: actions/setup-node@v4
        with: { node-version: 20 }

      - uses: actions/setup-dotnet@v4
        with: { dotnet-version: "8.0.x" }

      - uses: actions/setup-java@v4
        with:
          java-version: 17
          distribution: zulu

      - name: Install SonarScanner
        run: dotnet tool update dotnet-sonarscanner --tool-path ${{ runner.temp }}/scanner

      - name: Frontend install
        working-directory: front
        run: npm ci

      - name: Frontend tests
        working-directory: front
        shell: bash
        run: |
          if npm run | grep -q "test"; then
            npm run test -- --coverage --coverage.reporter=lcov
          else
            echo "‚ö†Ô∏è Aucun test d√©fini, √©tape ignor√©e."
          fi

      - name: SonarCloud begin
        shell: pwsh
        run: >
          ${{ runner.temp }}/scanner/dotnet-sonarscanner begin
          /k:"RMurier_porty"
          /o:"rmurier"
          /d:sonar.host.url="https://sonarcloud.io"
          /d:sonar.token="${{ env.SONAR_TOKEN }}"
          /d:sonar.sourceEncoding="UTF-8"

      - name: Build & Test backend
        working-directory: api
        run: |
          dotnet restore
          dotnet build -c Release
          dotnet test -c Release --no-build

      - name: SonarCloud end
        shell: pwsh
        run: >
          ${{ runner.temp }}/scanner/dotnet-sonarscanner end
          /d:sonar.token="${{ env.SONAR_TOKEN }}"

  docker-api:
    name: üê≥ Build & Push API Image
    runs-on: ubuntu-latest
    if: github.ref_name == 'develop' || github.ref_name == 'master'
    outputs:
      image: ${{ steps.publish.outputs.image }}
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-dotnet@v4
        with: { dotnet-version: "8.0.x" }

      - name: Login to GHCR
        run: echo "${{ secrets.TOKEN_GITHUB }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

      - id: publish
        name: Publish .NET API & Assemble Image
        shell: bash
        run: |
          dotnet publish api -c Release -o publish/
          BASE_IMAGE="mcr.microsoft.com/dotnet/aspnet:8.0"
          IMAGE_TAG="ghcr.io/${{ env.IMAGE_NAME }}:${{ github.sha }}"

          docker pull "$BASE_IMAGE"
          CID=$(docker create "$BASE_IMAGE")
          docker cp publish/. "$CID":/app/
          docker commit \
            --change='WORKDIR /app' \
            --change='ENTRYPOINT ["dotnet","/app/api.dll"]' \
            "$CID" "$IMAGE_TAG"
          docker rm "$CID"

          docker push "$IMAGE_TAG"
          echo "image=$IMAGE_TAG" >> $GITHUB_OUTPUT

  docker-front:
    name: üåê Build & Push Frontend Image
    runs-on: ubuntu-latest
    if: github.ref_name == 'develop' || github.ref_name == 'master'
    outputs:
      image: ${{ steps.push.outputs.image }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with: { node-version: 20 }

      - name: Login to GHCR
        run: echo "${{ secrets.TOKEN_GITHUB }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

      - name: Build frontend
        working-directory: front
        run: |
          npm ci
          npm run build

      - name: Build NGINX image
        id: push
        shell: bash
        run: |
          IMAGE_TAG="ghcr.io/${{ env.FRONT_IMAGE_NAME }}:${{ github.sha }}"
          mkdir -p docker-tmp/nginx
          cp -r front/dist/* docker-tmp/nginx/

          cat <<EOF > docker-tmp/Dockerfile
          FROM nginx:alpine
          COPY . /usr/share/nginx/html
          EXPOSE 80
          EOF

          docker build -t "$IMAGE_TAG" docker-tmp
          docker push "$IMAGE_TAG"
          echo "image=$IMAGE_TAG" >> $GITHUB_OUTPUT

  deploy:
    name: üöÄ Deploy to K3S
    runs-on: ubuntu-latest
    needs: [docker-api, docker-front]
    if: github.ref_name == 'develop' || github.ref_name == 'master'
    steps:
      - uses: actions/checkout@v4

      - name: Setup kubectl
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBE_CONFIG }}" > ~/.kube/config
          chmod 600 ~/.kube/config

      - name: Namespaces
        run: |
          kubectl apply -f k8s/namespace-prod.yaml
          kubectl apply -f k8s/namespace-staging.yaml

      - name: Select namespace
        id: envsel
        run: |
          if [ "${GITHUB_REF_NAME}" = "master" ]; then
            echo "namespace=production" >> $GITHUB_OUTPUT
          else
            echo "namespace=staging" >> $GITHUB_OUTPUT
          fi

      - name: Apply ClusterIssuer
        run: kubectl apply -f k8s/cluster-issuer.yaml

      - name: Decode compose & extract connection string
        id: conn
        shell: bash
        run: |
          YQ_VERSION=v4.44.3
          sudo curl -L "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64" -o /usr/local/bin/yq
          sudo chmod +x /usr/local/bin/yq

          if [ "${GITHUB_REF_NAME}" = "master" ]; then
            echo "${{ secrets.DOCKER_COMPOSE_PROD_B64 }}" | base64 --decode > compose.yml
          else
            echo "${{ secrets.DOCKER_COMPOSE_DEV_B64 }}" | base64 --decode > compose.yml
          fi

          CONN=$(yq -r '.services.api.environment["ConnectionStrings__DefaultConnection"] // ""' compose.yml)
          if [ -z "$CONN" ] || [ "$CONN" = "null" ]; then
            echo "‚ùå ConnectionStrings__DefaultConnection introuvable"; exit 1
          fi
          CONN_ESC="${CONN//%/%%}"
          echo "connection_string=$CONN_ESC" >> $GITHUB_OUTPUT

      - name: Apply manifests
        shell: bash
        run: |
          export APP_NAME=${{ env.APP_NAME }}
          export FRONT_APP_NAME=${{ env.FRONT_APP_NAME }}
          export CONTAINER_PORT=${{ env.CONTAINER_PORT }}
          export IMAGE=${{ needs.docker-api.outputs.image }}
          export FRONT_IMAGE=${{ needs.docker-front.outputs.image }}
          export HEALTH_PATH=${{ env.HEALTH_PATH }}

          if [ "${GITHUB_REF_NAME}" = "master" ]; then
            export HOSTNAME=${{ env.PROD_HOST }}
          else
            export HOSTNAME=${{ env.STAGING_HOST }}
          fi

          export CONNECTION_STRING='${{ steps.conn.outputs.connection_string }}'

          for f in k8s/*.yaml; do
            echo "üìÑ Applying $f"
            envsubst < "$f" | kubectl -n ${{ steps.envsel.outputs.namespace }} apply -f -
          done

      - name: Rollout status
        run: |
          kubectl -n ${{ steps.envsel.outputs.namespace }} rollout status deploy/${{ env.APP_NAME }} --timeout=180s || true
          kubectl -n ${{ steps.envsel.outputs.namespace }} rollout status deploy/${{ env.FRONT_APP_NAME }} --timeout=180s || true
          kubectl -n ${{ steps.envsel.outputs.namespace }} get pods