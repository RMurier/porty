name: CI/CD Porty

on:
  push:
    branches: ['**']
  pull_request:
    types: [opened, synchronize, reopened]

env:
  APP_NAME: porty
  MAIN_SERVICE: api
  CONTAINER_PORT: "8080"
  HEALTH_PATH: "/healthz"
  PROD_HOST: "murierromain.com"
  STAGING_HOST: "test.murierromain.com"
  REGISTRY: ghcr.io
  IMAGE_NAME: rmurier/porty

jobs:
  analyze:
    name: ðŸ§ª Build & SonarCloud Scan
    runs-on: windows-latest
    env:
      SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      DOTNET_COVERAGE: "**/TestResults/**/coverage.opencover.xml"
      DOTNET_TRX: "**/TestResults/*.trx"
      FRONT_LCOV: "front/coverage/lcov.info"

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "8.0.x"

      - uses: actions/setup-java@v4
        with:
          java-version: 17
          distribution: "zulu"

      - run: dotnet tool update dotnet-sonarscanner --tool-path ${{ runner.temp }}/scanner

      - working-directory: front
        run: npm ci

      - name: Frontend tests
        working-directory: front
        shell: bash
        run: |
          if npm run | grep -q "test"; then
            npm run test -- --coverage --coverage.reporter=lcov
          else
            echo "âš ï¸ Aucun test dÃ©fini, Ã©tape ignorÃ©e."
          fi

      - name: SonarCloud begin
        shell: pwsh
        run: >
          ${{ runner.temp }}/scanner/dotnet-sonarscanner begin
          /k:"RMurier_porty"
          /o:"rmurier"
          /d:sonar.host.url="https://sonarcloud.io"
          /d:sonar.token="${{ env.SONAR_TOKEN }}"
          /d:sonar.sourceEncoding="UTF-8"

      - name: Build & Test backend
        working-directory: api
        run: |
          dotnet restore
          dotnet build -c Release
          dotnet test -c Release --no-build

      - name: SonarCloud end
        shell: pwsh
        run: >
          ${{ runner.temp }}/scanner/dotnet-sonarscanner end
          /d:sonar.token="${{ env.SONAR_TOKEN }}"

  docker:
    name: ðŸ³ Push Compose Images
    runs-on: ubuntu-latest
    if: github.ref_name == 'develop' || github.ref_name == 'master'
    steps:
      - uses: actions/checkout@v4

      - name: Login to GHCR
        run: echo "${{ secrets.TOKEN_GITHUB }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

      - name: Recreate docker-compose from secrets
        id: compose
        shell: bash
        run: |
          if [ "${GITHUB_REF_NAME}" = "master" ]; then
            echo "${{ secrets.DOCKER_COMPOSE_PROD_B64 }}" | base64 --decode > docker-compose.yml
            echo "compose_file=docker-compose.yml" >> $GITHUB_OUTPUT
          else
            echo "${{ secrets.DOCKER_COMPOSE_DEV_B64 }}" | base64 --decode > docker-compose.dev.yml
            echo "compose_file=docker-compose.dev.yml" >> $GITHUB_OUTPUT
          fi
          ls -lh docker-compose*.yml

      - name: Push base image as GHCR tag
        shell: bash
        run: |
          IMAGE="ghcr.io/${{ env.IMAGE_NAME }}:${{ github.sha }}"
          echo "âš™ï¸ Tagging base image â†’ $IMAGE"
          docker pull mcr.microsoft.com/dotnet/sdk:8.0
          docker tag mcr.microsoft.com/dotnet/sdk:8.0 "$IMAGE"
          docker push "$IMAGE"

      - name: Save image ref
        run: echo "image=ghcr.io/${{ env.IMAGE_NAME }}:${{ github.sha }}" >> $GITHUB_ENV

  deploy:
    name: ðŸš€ Deploy to K3S
    runs-on: ubuntu-latest
    needs: docker
    if: github.ref_name == 'develop' || github.ref_name == 'master'
    steps:
      - uses: actions/checkout@v4

      - name: Setup kubectl
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBE_CONFIG }}" > ~/.kube/config
          chmod 600 ~/.kube/config
          kubectl version --client

      - name: Create namespaces
        run: |
          kubectl apply -f k8s/namespace-prod.yaml
          kubectl apply -f k8s/namespace-staging.yaml

      - name: Select namespace
        id: envsel
        run: |
          if [ "${GITHUB_REF_NAME}" = "master" ]; then
            echo "namespace=production" >> $GITHUB_OUTPUT
          else
            echo "namespace=staging" >> $GITHUB_OUTPUT
          fi

      - name: Apply manifests (with variable substitution)
        run: |
            export APP_NAME=${{ env.APP_NAME }}
            export CONTAINER_PORT=${{ env.CONTAINER_PORT }}
            if [ "${GITHUB_REF_NAME}" = "master" ]; then
            export HOSTNAME=${{ env.PROD_HOST }}
            else
            export HOSTNAME=${{ env.STAGING_HOST }}
            fi

            # Substitution et application en un coup
            for file in k8s/*.yaml; do
            echo "ðŸ“„ Applying $file with env substitution..."
            envsubst < "$file" | kubectl -n ${{ steps.envsel.outputs.namespace }} apply -f -
            done


      - name: Update image
        run: |
          kubectl -n ${{ steps.envsel.outputs.namespace }} set image deployment/${{ env.APP_NAME }} \
            ${{ env.APP_NAME }}=${{ env.image }} --record
          kubectl -n ${{ steps.envsel.outputs.namespace }} rollout status deployment/${{ env.APP_NAME }} --timeout=180s
